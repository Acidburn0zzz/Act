Act - documentation for developers

* Global variables available at runtime

  use Act::Config;

which exports two globals: $Config and %Request

$Config  current configuration.
$Config->foo_bar  retrieves value of configuration parameter foo in section bar

Configuration parameters coming from .ini files are currently all string values.
These additional parameters are also available

  $Config->conferences   a reference to a hash whose keys are the conference names
  $Config->languages     a reference to a hash whose keys are the language codes

%Request  current request object

A hash which holds information about the current request.

r            the Apache request object.
args         a hashref to the query's parameters
language     client language code
conference   name of the current conference if applicable
path_info    what's left of the URI that hasn't been parsed,
             in other words "conference/", if any, has been stripped
dbh          handle to the database. connect/disconnect is automatic.
user         a hashref to the current registered user, if applicable


* How to write a handler

Choose a suitable name space for your handler, we'll use Act::Handler::Foo.
Create your handler in lib/Foo.pm, naming your sub "handler".
In that sub:
- Figure out what to do, based on the query's arguments $Request{args}
  or maybe using $Request{path_info}
- Do it. You might need to query the database with $Request{dbh}
- In most cases you'll want to send an HTML page using a template
  Retrieve a template object:
    my $template = Act::Template::HTML->new;
  Create some template variables:
    $template->variables(
      name  => $user->{name},
    );
- Finally process the template. Its output will be sent to the client's
  browser
    $template->process('foo.html');
  Just provide the template's base name, don't use pathnames-- the template
  object knows about the current request and will know where to look.
  Template files in conference subdirectories override global templates.

Now choose an "action" word that best describes your handler. We'll use
the string "foo". We now associate that action word with our sub by
adding the mapping to the %dispatch hash in Act::Dispatcher.

  my %dispatch = (
    foo => { handler => 'Act::Handler::Foo' },
    ...
  );

This will enable this handler for all URLs that start with /conference/foo
where conference is a conference name, e.g.:
  /2004/foo
  /2004/foo?q=1
  /2004/foo/bar

If this action requires the user to be registered, add the key "private"
to the dispatch value:

  my %dispatch = (
    foo => { handler => 'Act::Handler::Foo', private => 1 },
    ...
  );

The user will be prompted for credentials (login and password) the first time
a protected page is requested in a given session.


* Templates

Act provides a set of classes that encapsulate Template Toolkit's functionality.
The base class is Act::Template, a subclass of Template to which it adds:
- automatic INCLUDE_PATH configuration
   A template's INCLUDE_PATH is the list of directories where TT searches
   for template files.
   When a new template is created (Act::Template->new), the INCLUDE_PATH
   is set according to current configuration and request: first any conference
   specific paths, if the current request is within a given conference, then
   the global template directories. This allows overriding global templates
   on a case by case basis.
- template object caching
   Act::Template->new acts as an object factory: it maintains an internal
   cache of template objects. This avoids the overhead associated with template
   object creation and leverages TT's internal compiled templates cache.
- multilingual templates
   Multiple versions of the same text can be included in a given template, using
   an XML-like syntax: 
     <t>...</t> surrounds a multilingual text section
     <xx>...</xx> surrounds a particular language version, where xx is a language
     code. Here's an example:
       <t><fr>Bonjour</fr><en>Hello</en></t>
   These language sections are parsed when TT compiles the template, and therefore
   have no impact on TT's compiled templates cache.
   At request time, Act::Template will process the appropriate language section
   according to the current request language.
- easier variable setting
   This is a convenience method. $template->variables() will accumulate template
   variable settings until template processing time.
- default output
   When no output argument is provided, Act::Template::process outputs to
   $Request{r}, which if in a web context will be the client's browser.
   Thus in the general case process() is called with a single argument, the
   template's filename.

Act::Template::HTML is a subclass of Act::Template which adds the following features:

- automatic HTML escaping of template variables: &, <, > are converted to HTML entities
  &amp; &lt; and &gt;. This works on nested data structures as well.


Several forms used by Act used the WRAPPER "ui" for adding the local
look&feel. The name "ui" is therefore the standard template for redefining
the user interface.
