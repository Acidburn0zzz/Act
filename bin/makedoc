#!/usr/bin/env perl
#
# Build a HTML tree from the Act POD manual.

use strict;

##########################
package MyView;
use base 'Pod::POM::View::HTML';

my $prefix = 'Act::';
my %meta_sections = map { $_ => 1 } qw(NAME);

sub is_meta_section
{
    my ($self, $name) = @_;
    return exists $meta_sections{$name};
}

sub page_depth
{
    my $self = shift;
    if (@_) {
        $self->{_act_makedoc_depth} = shift;
    }
    return $self->{_act_makedoc_depth};
}

sub view_pod
{
    my ($self, $pod) = @_;
    return $pod->content->present($self);
}
sub view_head1
{
    my ($self, $head1) = @_;
    my $title = $head1->title->present($self);

    if ($meta_sections{$title}) {
        return '';
    }
    my $html = $head1->content->present($self);
    if ($title eq 'DESCRIPTION') {
        return $html;
    }
    return "<h1>$title</h1>\n"
           . $head1->content->present($self);
}
sub view_seq_link_transform_path
{
    my ($self, $page) = @_;
    if ($page =~ /^$prefix/) {
        # a link to another man page
        $page =~ s/^$prefix//;
        $page =~ s|::|/|g;
        return '../' x $self->page_depth . $page . '.html';
    }
    warn "unknown link: $page\n";
    return;
}

###########################
package main;

use File::Basename        qw(dirname);
use File::Find            qw(find);
use File::Path            qw(mkpath);
use File::Spec::Functions qw(catfile);
use FindBin               qw($Bin);
use Getopt::Long          qw(GetOptions);
use Pod::POM              qw();
use Pod::POM::View::Text  qw();
use Pod::Usage            qw(pod2usage);
use Template              qw();

# parse command line
my ($help, $verbose, $dryrun, $acthome, $baseurl);
Getopt::Long::Configure('bundling');
GetOptions(
    'help|h'    => \$help,
    'verbose|v' => \$verbose,
    'dryrun|n'  => \$dryrun,
    'acthome:s' => \$acthome,
    'baseurl:s' => \$baseurl,
) or pod2usage(0);
pod2usage(1) if $help;
$acthome ||= "$Bin/..";
$baseurl ||= '';
my $srcdir  = catfile($acthome, "lib/Act");
-d $srcdir or pod2usage("Can't determine ACTHOME");
my $destdir = shift or pod2usage("You must specify a destination directory!");

# create POD parser and view and template objects
my $parser = Pod::POM->new(warn => 1);
my $view_html = MyView->new;
my $view_text = Pod::POM::View::Text->new;
my $template = Template->new(
   INCLUDE_PATH => catfile($acthome, qw(templates manual)),
   UNICODE  => 1,
   ENCODING => 'UTF-8',
);

# find all pod files
my @files;
my $wanted = sub {
    $File::Find::prune = 1 if -d && /\A(?:CVS|\.svn)\b/;
    -f && /.pod$/ && push @files, $File::Find::name;
};
find( $wanted, $srcdir );

# convert pod to html
for my $pathname (@files) {
    # filename relative to source directory
    (my $file = $pathname) =~ s|^$srcdir/||;
    print "$file" if $verbose;
    
    # read file
    my $pod = do {
        local $/ = undef;
        open my $fh, '<:encoding(UTF-8)', $pathname
            or die "can't open $pathname for reading: $!\n";
        <$fh>;
    };
    # determine this file's depth within the tree,
    # this will be used by the view to make relative links
    my $depth = () = $file =~ m|/|g;
    $view_html->page_depth($depth);

    # parse and render the POD
    my $pom = $parser->parse_text($pod);
    my $html = $pom->present($view_html);

    # determine pathname of output file
    $file =~ s/\.pod$/.html/;
    $file = catfile($destdir, $file);
    print "  => $file\n" if $verbose;
    next if $dryrun;

    # create destination directory
    my $dir = dirname($file);
    -d $dir or mkpath($dir);

    # retrieve meta data
    my %meta;
    for my $head1 ($pom->head1()) {
        if (MyView->is_meta_section($head1->title())) {
            my $text = $head1->content->present($view_text);
            $text =~ s/\s+$//;
            $meta{ $head1->title() } = $text;
        }
    }
    # process file through our page template
    open my $fh, '>:encoding(UTF-8)', $file
        or die "can't open $file for writing: $!\n";
    $template->process(
        'page',
        {
          content => $html,
          meta    => \%meta,
          baseurl => $baseurl,
        },
        $fh);
}
__END__

=head1 NAME

makedoc - build HTML tree from Act's POD documenation (Act::Manual)

=head1 SYNOPSIS

makedoc [options] destination_directory

 Options:
   -a, --acthome <acthome>     specify alternate ACTHOME
   --baseurl <url>             specify static resource root URL
   -h, --help                  prints brief help text
   -n, --dryrun                dry run
   -v, --verbose               verbose

=head1 OPTIONS

=over 4

=item B<--help>

Prints a brief help message and exits.

=item B<--acthome>

Specify an alternate Act home directory. C<makedoc> will look for POD files
in that directory's F<lib/Act> subdirectory.

Defaults to the parent directory

=item B<--dryrun>

Processes the POD files without saving them.

=item B<--baseurl>

Specify the URL of the root of the mandocs. It is prepended to links to static
resources such as CSS stylesheets and image files.
Do not include a trailing slash.

Defaults to the empty string.

Example:

Build the HTML docs as a subdirectory the root of an Act checkout, and use the supplied static
resources (images and stylesheets) files in F<mandocs/>:

  act% bin/makedocs --baseurl=${PWD}/mandocs docs

This will create an HTML tree suitable for local (C<file://) viewing.

=item B<--verbose>

Prints information on each processed POD file.

=back

=head1 DESCRIPTION

B<makedoc> converts the Act manual's POD file tree into an HTML file tree.
It doesn't rely on a correctly configured running Act installation,
only on a directory where pod files can be found in F<lib/Act/>.

=cut
